{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nexports.__esModule = true;\nexports.getIn = getIn;\nexports.default = void 0;\nvar _propertyExpr = require(\"property-expr\");\nvar _has = _interopRequireDefault(require(\"lodash/has\"));\nvar trim = function trim(part) {\n  return part.substr(0, part.length - 1).substr(1);\n};\nfunction getIn(schema, path, value, context) {\n  var parent, lastPart, lastPartDebug; // if only one \"value\" arg then use it for both\n\n  context = context || value;\n  if (!path) return {\n    parent: parent,\n    parentPath: path,\n    schema: schema\n  };\n  (0, _propertyExpr.forEach)(path, function (_part, isBracket, isArray) {\n    var part = isBracket ? trim(_part) : _part;\n    if (isArray || (0, _has.default)(schema, '_subType')) {\n      // we skipped an array: foo[].bar\n      var idx = isArray ? parseInt(part, 10) : 0;\n      schema = schema.resolve({\n        context: context,\n        parent: parent,\n        value: value\n      })._subType;\n      if (value) {\n        if (isArray && idx >= value.length) {\n          throw new Error(\"Yup.reach cannot resolve an array item at index: \" + _part + \", in the path: \" + path + \". \" + \"because there is no value at that index. \");\n        }\n        value = value[idx];\n      }\n    }\n    if (!isArray) {\n      schema = schema.resolve({\n        context: context,\n        parent: parent,\n        value: value\n      });\n      if (!(0, _has.default)(schema, 'fields') || !(0, _has.default)(schema.fields, part)) throw new Error(\"The schema does not contain the path: \" + path + \". \" + (\"(failed at: \" + lastPartDebug + \" which is a type: \\\"\" + schema._type + \"\\\") \"));\n      schema = schema.fields[part];\n      parent = value;\n      value = value && value[part];\n      lastPart = part;\n      lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;\n    }\n  });\n  return {\n    schema: schema,\n    parent: parent,\n    parentPath: lastPart\n  };\n}\nvar reach = function reach(obj, path, value, context) {\n  return getIn(obj, path, value, context).schema;\n};\nvar _default = reach;\nexports.default = _default;","map":{"version":3,"names":["_interopRequireDefault","require","exports","__esModule","getIn","default","_propertyExpr","_has","trim","part","substr","length","schema","path","value","context","parent","lastPart","lastPartDebug","parentPath","forEach","_part","isBracket","isArray","idx","parseInt","resolve","_subType","Error","fields","_type","reach","obj","_default"],"sources":["/Users/GAMJA/Desktop/nodejs프로젝트/boilerplate-mern-stack-master/client/node_modules/yup/lib/util/reach.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.getIn = getIn;\nexports.default = void 0;\n\nvar _propertyExpr = require(\"property-expr\");\n\nvar _has = _interopRequireDefault(require(\"lodash/has\"));\n\nvar trim = function trim(part) {\n  return part.substr(0, part.length - 1).substr(1);\n};\n\nfunction getIn(schema, path, value, context) {\n  var parent, lastPart, lastPartDebug; // if only one \"value\" arg then use it for both\n\n  context = context || value;\n  if (!path) return {\n    parent: parent,\n    parentPath: path,\n    schema: schema\n  };\n  (0, _propertyExpr.forEach)(path, function (_part, isBracket, isArray) {\n    var part = isBracket ? trim(_part) : _part;\n\n    if (isArray || (0, _has.default)(schema, '_subType')) {\n      // we skipped an array: foo[].bar\n      var idx = isArray ? parseInt(part, 10) : 0;\n      schema = schema.resolve({\n        context: context,\n        parent: parent,\n        value: value\n      })._subType;\n\n      if (value) {\n        if (isArray && idx >= value.length) {\n          throw new Error(\"Yup.reach cannot resolve an array item at index: \" + _part + \", in the path: \" + path + \". \" + \"because there is no value at that index. \");\n        }\n\n        value = value[idx];\n      }\n    }\n\n    if (!isArray) {\n      schema = schema.resolve({\n        context: context,\n        parent: parent,\n        value: value\n      });\n      if (!(0, _has.default)(schema, 'fields') || !(0, _has.default)(schema.fields, part)) throw new Error(\"The schema does not contain the path: \" + path + \". \" + (\"(failed at: \" + lastPartDebug + \" which is a type: \\\"\" + schema._type + \"\\\") \"));\n      schema = schema.fields[part];\n      parent = value;\n      value = value && value[part];\n      lastPart = part;\n      lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;\n    }\n  });\n  return {\n    schema: schema,\n    parent: parent,\n    parentPath: lastPart\n  };\n}\n\nvar reach = function reach(obj, path, value, context) {\n  return getIn(obj, path, value, context).schema;\n};\n\nvar _default = reach;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}